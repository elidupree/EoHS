this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- persistence.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type
local wesnoth,table,string,math,os,debug,wml,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,wml,EoHS.helper,EoHS._,EoHS,_G,nil

--[[

Notes about the persistent variables system:
[get_global_variable] always attempts to sync,
  and therefore will emit error messages if I use it when disunified.
Also, wesnoth formerly didn't implement a way to use [get_global_variable] to
  retrieve a variable on a different player's turn.
  Therefore, [get_global_variable] could only be used to check $player's variables on $player's turn.
[set_global_variable] never attempts to sync and has always been usable locally and/or off-turn.
  However, without a corresponding [get_global_variable], it can only overwrite values,
  not update them.

To explain our old workarounds for this, imagine that there's an action that scores one point.

Case 1: Alice scores on Alice's turn.
    Alice retrieves global!score:
      -> Bob receives global!score, ignores it
      -> Alice receives global!score, puts to local!score
    Alice adds 1 to local!score
    Alice stores local!score to global!score

Case 2: Alice scores on Bob's turn.
    Alice adds "score a point" to local!transaction
    Alice stores local!transaction to global!transaction (***)
    (perhaps this happens multiple times before Alice's turn)
  Alice's turn begins (either in this game or another one)
    Alice retrieves global!transaction
      -> Bob receives global!transaction, ignores it
      -> Alice receives global!transaction, puts to local!transaction
    For each "score a point" in local!transaction:
      Alice retrieves global!score:
        -> Bob receives global!score, ignores it
        -> Alice receives global!score, puts to local!score
      Alice adds 1 to local!score
      Alice stores local!score to global!score
    Alice clears local!transaction and global!transaction
    
(***) is theoretically destructive. However, it loses data only if Alice loses local!transaction
  (by the game ending) and then records ANOTHER transaction before zir turn.
  This can happen in two ways:
  Problem 1: Alice scores before zir turn 1.
  Problem 2: Alice is given control of a networked side during another side's turn.
  
  To deal with these, every player records the current local is_local each time ze updates the transations (i.e. each of zir turns).
  Transactions are only created for sides that are human now AND were human last turn.
  So you can't earn points before getting a turn. So sad :,(

]]

local get_persistent_variable__stored = function(side, name) return EoHS.get_side_variable(side, "persistent_variables."..name) end
local set_persistent_variable__stored = function(side, name, value) EoHS.set_side_variable(side, "persistent_variables."..name, value) end

local set_persistent_variable__impl = function(side, name, value)
  -- protect against the consequences of my own hack below:
  EoHS.assert (value ~= "", "storing the empty string in a persistent variable is buggy")
  if value == nil then
    wesnoth.fire("clear_global_variable", { namespace="EoHS_Era_of_High_Sorcery",      global=name, side=side, immediate=true })
  else
    wml.variables["EoHS.LUA_TEMP"] = value
    wesnoth.fire(  "set_global_variable", { namespace="EoHS_Era_of_High_Sorcery",   to_global=name, side=side, immediate=true, from_local="EoHS.LUA_TEMP" })
    wml.variables["EoHS.LUA_TEMP"] = nil
    wesnoth.set_variable("EoHS.LUA_TEMP")
  end
end

local get_persistent_variable__network = function(side, name)
  if EoHS.context.synchronized then
    wesnoth.fire(  "get_global_variable", { namespace="EoHS_Era_of_High_Sorcery", from_global=name, side=side,   to_local="EoHS.LUA_TEMP" })
    local result = wml.variables["EoHS.LUA_TEMP"]
    wml.variables["EoHS.LUA_TEMP"] = nil
    -- hack: wesnoth always returns the empty string for nonexistent global variables,
    -- instead of nil, as it does for regular wesnoth variables.
    -- let's make this more consistent for EoHS purposes.
    if result == "" then return nil end
    return result
  else EoHS.err("get_persistent_variable__network used in an unsynchronized context") end
end

local fetch_persistent_variable = function(side, name)
  local value = get_persistent_variable__network(side, name)
  set_persistent_variable__stored(side, name, value)
  return value
end

-- If you use this in a nonsynchronized way, it DOES work, but you need to use fetch_persistent_variable if you want it to be visible to other players.
local set_proper_persistent_variable = function(side, name, value)
  if name ~= "attribute_list" then
    local old = get_persistent_variable__stored(side, name)
    local new_list = string.gsub(get_persistent_variable__stored(side, "attribute_list") or "", ","..EoHS.lua_pattern_escape(name), "")
    if value ~= nil then
      new_list = new_list..","..name
    end
    set_persistent_variable__stored(side, "attribute_list", new_list)
    set_persistent_variable__impl(side, "attribute_list", new_list)
  end
  
  set_persistent_variable__stored(side, name, value)
  set_persistent_variable__impl(side, name, value)
end

-- We check both nick and ID so that:
-- You don't score twice for defeating, e.g., Elvish_Pillager and Elvish_Pillager2
--   if Elvish_Pillager sometimes uses the latter nick after getting disconnected,
-- And you don't score twice for defeating Elvish_Pillager twice if Elvish_Pillager
--   plays on two different devices.
-- You can score twice if both of those happen, but there's not much I can do about that.
local add_to_nick_and_id_list = function(side, nick, id, nick_list_name, id_list_name)
  nick = string.gsub(nick, ",", "")
  local nick_list = get_persistent_variable__stored(side, nick_list_name) or ","
  local   id_list = get_persistent_variable__stored(side,   id_list_name) or ","
  if (not string.match(nick_list, ","..EoHS.lua_pattern_escape(nick)..",")) and (not string.match(id_list, id)) then
    nick_list = nick_list..nick..","
      id_list =   id_list..  id..","
    set_proper_persistent_variable(side, nick_list_name, nick_list)
    set_proper_persistent_variable(side,   id_list_name,   id_list)
    return true
  end
  return false
end

local update_supporter_status
local apply_persistent_transaction = function(side, transaction)
  local transaction_type, transaction_args = string.match(transaction, "(.-)%((.*)%)")
  if transaction_type == "add_supporter_password" then
    local password_list = get_persistent_variable__stored(side, "supporter_passwords") or ""
    password_list = password_list..transaction_args..","
    set_proper_persistent_variable(side,"supporter_passwords", password_list)
    update_supporter_status(side)
  end
  if transaction_type ==   "defeated_player" then
    local nick, id = string.match(transaction_args, "(.-),(.+)")
    add_to_nick_and_id_list(side, nick, id,   "defeated_nicks",   "defeated_identities")
  end
  if transaction_type == "introduced_player" then
    local nick, id = string.match(transaction_args, "(.-),(.+)")
    add_to_nick_and_id_list(side, nick, id, "introduced_nicks", "introduced_identities")
  end
  if transaction_type == "killed_wizard_with_staff" then
    set_proper_persistent_variable(side, "killed_wizard_with_staff", true)
  end
end

local record_persistent_transaction = function(side, transaction)
  apply_persistent_transaction(side, transaction)
  --[[if side == wesnoth.current.side then
    apply_persistent_transaction_of_current_side(transaction)
  else
    EoHS.do_only_on_client_controlling_human_side(side, function()
      if EoHS.get_side_variable(side, "client_was_local_last_update") then
        local transactions = EoHS.get_variable("client_local_persistent_transactions") or ""
        transactions = transactions.."BEGIN_TRANSACTION"..transaction.."END_TRANSACTION"
        EoHS.set_variable("client_local_persistent_transactions", transactions)
        set_persistent_variable__impl(side, "transactions", transactions)
      end
    end)
  end]]
end

-- Note: I'm well aware of how insecure this is against a user who knows programming.
-- You could even make an add-on that automatically gives people supporter status.
--   By the way, please don't do that.
-- If I had wanted more security, I could have implemented public-key cryptography in
--   pure Lua, so that I was the only one who could issue codes that work for each nick -
--   but no matter what I do, people can be fake supporters when they *host* a game
--   just by changing the add-on code. Given that gap, I didn't feel that securing the
--   other side (cheating player with a legitimate host) was worth the effort.
EoHS.password_for_nick = function(nick)
  return string.sub(string.gsub(EoHS.sha1(nick), "[^%d]", ""), 1, 10)
end
update_supporter_status = function(side)
  local found_supporter = false
  local units = EoHS.get_units({ side=side, EoHS.is_on_the_map, EoHS.has_unit_variable("is_wizard") })
  for i,unit in ipairs(units) do
    local modifications = EoHS.force_subtag(unit, "modifications")
    local trait,idx = wml.get_child(modifications, "trait", "EoHS_supporter")
    local has_password_for = function(nick) return string.match(get_persistent_variable__stored(side, "supporter_passwords") or "", EoHS.password_for_nick(nick)) end
    local orig_nick = EoHS.get_side_variable(side, "original_nick")
    local good_nick = ((type(unit.name) == "string") and has_password_for(unit.name) and unit.name) or
                      ((type(orig_nick) == "string") and has_password_for(orig_nick) and orig_nick)
    if good_nick then
      found_supporter = true
      if not (trait or wml.get_child(modifications, "trait", "author")) then
        table.insert(modifications, 1, (good_nick == "Elvish_Pillager") and EoHS.author_trait or {"trait",{
          id = "EoHS_supporter",
          name = _"magnanimous",
          description = EoHS.substitute(_"$1| has generously donated to help Eli keep developing Era of High Sorcery. Visit www.elidupree.com/EoHS to donate.", {good_nick}),
        }})
        EoHS.put_unit(unit)
      end
    else
      if trait then
        table.remove(modifications, idx)
        EoHS.put_unit(unit)
      end
    end
  end
  EoHS.set_side_variable(side, "is_supporter", found_supporter)
end
EoHS.is_valid_supporter_password = function(side, password)
  local nick_to_match = EoHS.get_side_variable(side, "original_nick")
  if (type(nick_to_match) == "string") and (EoHS.password_for_nick(nick_to_match) == password) then
    return true
  end
  return false
end
EoHS.add_supporter_password = function(side, password)
  record_persistent_transaction(side, "add_supporter_password("..password..")")
end

-- Basically idempotent; should be called every so often, but mainly at the beginning
-- and end of each game. Games don't usually take more than 24 hours.
-- Note that this function SHOULDN'T be called for observers.
local player_is_playing_right_now = function(side)
  local time = os.time()
  local hours = 60*60
  local days = 24*hours
  EoHS.do_only_on_client_controlling_side(side, function()
    local reference_time_played = get_persistent_variable__stored(side, "reference_time_played")
    if reference_time_played then
      -- Without this hack, Wesnoth will apply floating-point rounding to it
      reference_time_played = tonumber(string.match(reference_time_played, "large_number_storing_hack_(.+)"))
      local time_since_reference_point = os.difftime(time, reference_time_played)
      local num_days_played_continuously = get_persistent_variable__stored(side, "num_days_played_continuously") or 0
      local time_since_last_day_end = time_since_reference_point - num_days_played_continuously*days
      if time_since_last_day_end > 8*hours then
        set_proper_persistent_variable(side, 
          "total_days_played", get_persistent_variable__stored(side, "total_days_played") + 1)
        if time_since_last_day_end > 1*days then
          set_proper_persistent_variable(side, 
            "reference_time_played", "large_number_storing_hack_"..time)
          set_proper_persistent_variable(side,
            "num_days_played_continuously", 0)
        else
          set_proper_persistent_variable(side, 
            "num_days_played_continuously", num_days_played_continuously + 1)
        end
      end
    else
      set_proper_persistent_variable(side, 
        "reference_time_played", "large_number_storing_hack_"..time)
      set_proper_persistent_variable(side, 
        "total_days_played", 1)
    end
  end)
  fetch_persistent_variable(side, "attribute_list")
  fetch_persistent_variable(side, "total_days_played")
  fetch_persistent_variable(side, "reference_time_played")
  fetch_persistent_variable(side, "num_days_played_continuously")
end

local fetch_all_persistent_variables = function(side)
  local old_identity = get_persistent_variable__stored(side, "identity")
  EoHS.set_side_variable(side, "persistent_variables", {})
  
  local attribute_list = fetch_persistent_variable(side,"attribute_list") or ""
  for key in EoHS.comma_separated_values(attribute_list) do fetch_persistent_variable(side, key) end
  
  local identity = get_persistent_variable__stored(side, "identity")
  if not (identity and (string.len(identity) == string.len("0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33"))) then
    local uniqueness_source = EoHS.random("0..32767")..EoHS.random("0..32767")..EoHS.random("0..32767")..EoHS.random("0..32767")
    local nick = EoHS.get_side_variable(side, "original_nick")
    if type(nick) == "string" then uniqueness_source = uniqueness_source..nick end
    identity = EoHS.sha1(uniqueness_source)
    set_proper_persistent_variable(side, "identity", identity)
  end
  if not EoHS.get_side_variable(side, "original_identity") then
    EoHS.set_side_variable(side, "original_identity", identity)
    EoHS.set_side_variable(side, "is_newbie", not get_persistent_variable__stored(side, "introduced_nicks"))
  end
  
  -- retain the transactions code for now in case players have leftover transactions from old games
  local transactions = get_persistent_variable__network(side, "transactions")
  if transactions then
    for transaction in string.gmatch(transactions, "BEGIN_TRANSACTION(.-)END_TRANSACTION") do
      apply_persistent_transaction(side, transaction)
    end
    set_persistent_variable__impl(side, "transactions", nil)
  end
  
  if identity ~= old_identity then update_supporter_status(side) end
end
EoHS.update_and_share_persistent_variables_of_side = function(side)
  --[[local locality_changed = EoHS.synchronize_choice(
    EoHS.get_side_variable(wesnoth.current.side, "client_was_local_last_update") ~= wesnoth.sides[wesnoth.current.side].is_local)
  EoHS.set_side_variable(wesnoth.current.side, "client_was_local_last_update", wesnoth.sides[wesnoth.current.side].is_local)
  
  if locality_changed then
    fetch_all_persistent_variables (side)
  end]]
  
  local old_identity = get_persistent_variable__stored(side, "identity")
  if not (old_identity and old_identity == get_persistent_variable__network(side, "identity")) then
    fetch_all_persistent_variables (side)
  end
  EoHS.set_side_variable(wesnoth.current.side, "client_was_local_last_update", wesnoth.sides[wesnoth.current.side].is_local)
end

EoHS.update_and_share_persistent_variables = function()
  for side in ipairs (wesnoth.sides) do
    EoHS.update_and_share_persistent_variables_of_side(side)
  end
  player_is_playing_right_now(wesnoth.current.side)
end


EoHS.get_potentially_out_of_date_persistent_variable = function(side, name)
  -- do not fetch, because it blocks on the specified player responding to network
  -- (which wouldn't happen if they were, for instance, in a menu)
  --if EoHS.context.synchronized then
  --  return fetch_persistent_variable(side, name)
  --else
    return get_persistent_variable__stored(side, name)
  --end
end

EoHS.set_persistent_variable = function (side, name, value)
  set_proper_persistent_variable(side, name, value)
end

-- This is called at endgame or when they lose their last leader
EoHS.score_for_side_completing_game = function(side)
  -- Deliberately including the same side. You score one for yourself.
  -- Thus, a newbie is exactly "a person who hasn't scored for introducing any newbies".
  local id1 = get_persistent_variable__stored(side, "identity")
  local vars1 = EoHS.get_side_variables(side)
  if (not vars1.was_ever_ai) and (id1 == vars1.original_identity) then
    EoHS.set_side_variable(side, "side_properly_defeated", true)
    if EoHS.get_side_variable(side, "is_newbie") then
      for side2 in ipairs(wesnoth.sides) do
        local id2 = get_persistent_variable__stored(side2, "identity")
        local vars2 = EoHS.get_side_variables(side2)
        if (not vars2.was_ever_ai) and (id2 == vars2.original_identity) then
          if type(vars1.original_nick) == "string" then
            record_persistent_transaction(side2, "introduced_player("..string.gsub(vars1.original_nick,",","")..","..id1..")")
          end
        end
      end
    end
  end
end
EoHS.score_for_game_ending = function()
  local units = EoHS.get_units({ EoHS.is_on_the_map })
  local sides_alive = {}
  local any_newbies = false
  for i,unit in ipairs(units) do if unit.canrecruit then sides_alive[unit.side] = true end end
  for side1 in ipairs(wesnoth.sides) do
    local id1 = get_persistent_variable__stored(side1, "identity")
    local vars1 = EoHS.get_side_variables(side1)
    if (not vars1.was_ever_ai) and (id1 == vars1.original_identity) then
      for side2 in ipairs(wesnoth.sides) do
        local vars2 = EoHS.get_side_variables(side2)
        local id2 = vars2.original_identity
        if (id1 ~= id2) and wesnoth.is_enemy(side1, side2) and sides_alive[side1] and (not sides_alive[side2]) and vars2.side_properly_defeated then
          if type(vars2.original_nick) == "string" then
            record_persistent_transaction(side1,   "defeated_player("..string.gsub(vars2.original_nick,",","")..","..id2..")")
          end
        end
      end
    end
    if EoHS.get_side_variable(side1, "is_newbie") then any_newbies = true end
  end
  if not any_newbies then EoHS.display_donation_appeals() end
end
EoHS.score_for_staffing_wizard = function(side1, side2)
  local id1 = get_persistent_variable__stored(side1, "identity")
  local vars1 = EoHS.get_side_variables(side1)
  if (id1 == vars1.original_identity) then
    local vars2 = EoHS.get_side_variables(side2)
    local id2 = vars2.original_identity
    if (id1 ~= id2) and (not vars2.was_ever_ai) and (id2 == vars2.original_identity) then
      record_persistent_transaction(side1, "killed_wizard_with_staff()")
    end
  end
end

local count_nick_list = function(nick_list)
  if not nick_list then return 0 end
  local result = 0
  for victory in EoHS.comma_separated_values(nick_list) do result = result + 1 end
  return result
end

EoHS.num_players_defeated = function(side)
  return count_nick_list(EoHS.get_potentially_out_of_date_persistent_variable(side,   "defeated_nicks"))
end
EoHS.num_newbies_introduced = function(side)
  return count_nick_list(EoHS.get_potentially_out_of_date_persistent_variable(side, "introduced_nicks"))
end

local appeal_image
EoHS.soon(function()
  appeal_image = EoHS.collapse_image_aggregate("image_modded", EoHS.image_aggregates_combined(
    EoHS.image_aggregate_translated(EoHS.menu_rectangle_aggregate("opaque", 240, 150), {x=2, y=-1}),
    { image_modded = "items/gold-coins-small.png", offset = {x=-84,y=-4} },
    { image_modded = "items/gold-coins-medium.png", offset = {x=84,y=-16} }
  ))
end)

EoHS.display_donation_appeal = function(x, y)
  EoHS.set_hex_variable(x, y, "donation_appeal", true)
  EoHS.place_item({x=x, y=y, halo=appeal_image})
  wesnoth.fire("label", {x=x, y=y-1, color="249,238,23", visible_in_shroud=true, immutable=false, text=_"Support EoHS!\n\nI need money!"})
  wesnoth.fire("label", {x=x, y=y, color="162,192,255", visible_in_shroud=true, immutable=false, text=_"patreon.com/EoHS"})
end

EoHS.ok_for_donation_appeal = function(x, y)
  for i,hex in ipairs(EoHS.find_reach(x, y, nil, 4)) do
    if wesnoth.units.get(hex.x, hex.y) and (hex.cost <= 2) and not ((hex.cost == 2) and (hex.x == x)) then return false end
    if EoHS.get_hex_variable(hex.x, hex.y, "donation_appeal") then return false end
  end
  return true
end

EoHS.display_donation_appeals = function()
  local w,h = wesnoth.get_map_size()
  for i=1,w*h/5 do
    local x,y = EoHS.random("3.."..(w-2)), EoHS.random("2.."..(h-1))
    if EoHS.ok_for_donation_appeal(x,y) then EoHS.display_donation_appeal(x,y) end
  end
  --[[for x=4,w,7 do
    for y=4-((x%2)*2),h,5 do
      EoHS.display_donation_appeal(x,y)
    end
  end]]
end

-->>)}
