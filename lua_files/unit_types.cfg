this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- unit_types.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type
local wesnoth,table,string,math,os,debug,wml,gui,filesystem,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,wml,gui,filesystem,EoHS.helper,EoHS._,EoHS,_G,nil

EoHS.do_special_advancement_next = function(unit)
  return EoHS.get_unit_variable(unit, "is_wizard") or ((unit.advances_to == unit.type) and EoHS.get_unit_variable(unit, "is_summon"))
end


EoHS.wizard_max_experience = function(level)
  return (level+2)*(level+2)*17
end
EoHS.wizard_shared_experience_limit = function(unit)
  -- use the variable so also it works on wunits
  return (EoHS.get_unit_variable(unit, "wizard_level")+2)*12
end
local wizard_max_hitpoints_table = {
  wesnoth.unit_types[      "Mage"].max_hitpoints,
  wesnoth.unit_types[  "Red Mage"].max_hitpoints,
  wesnoth.unit_types[ "Arch Mage"].max_hitpoints,
  wesnoth.unit_types["Great Mage"].max_hitpoints,
}
EoHS.wizard_max_hitpoints = function(level)
  local val
      if level < 1 then val = math.ceil(wizard_max_hitpoints_table[1] / (2-level))
  elseif level > 4 then val = wizard_max_hitpoints_table[4] + (11*(level - 4))
  else val = wizard_max_hitpoints_table[level] end
  return val + 10
end
local wizard_advancement_lines = {
  {"Mage","Red Mage","Arch Mage","Great Mage"},
  {"White Mage","White Mage","Mage of Light"},
  {"Dark Adept","Dark Sorcerer","Necromancer"},
  {"Dwarvish Runesmith","Dwarvish Runesmith","Dwarvish Runemaster","Dwarvish Arcanister"},
  {"Elvish Lord","Elvish Lord","Elvish High Lord"},
  {"Saurian Augur","Saurian Soothsayer"},
  {"Mermaid Initiate","Mermaid Enchantress","Mermaid Siren"},
  {"Mermaid Priestess","Mermaid Priestess","Mermaid Diviner"},
}
for i,line in ipairs(wizard_advancement_lines) do
  for i,unit_type in ipairs(line) do
    line[unit_type] = true
    wizard_advancement_lines[unit_type] = line
  end
end
local same_line = function(unit_type1, unit_type2)
  if unit_type1 == unit_type2 then return true end
  local line = wizard_advancement_lines[unit_type1]
  return line and line[unit_type2] or false
end
EoHS.appropriate_wizard_unit_type = function(reference_type, level)
  local line = wizard_advancement_lines[reference_type]
  if line then
    if level < 1 then return line[1] end
    return line[level] or line[#line]
  end
  
  return nil
end
EoHS.is_building = function(unit)
  return EoHS.get_unit_variable(unit, "is_building")
end
EoHS.custom_races = {
  --EoHS_building = { name=_"Building", base_race = "mechanical" },
  EoHS_magic = { name=_"Magical force", base_race = "monster" },
  EoHS_cat = { name=_"Cat", base_race = "monster" },
}
EoHS.unit_race = function(unit)
  return EoHS.get_unit_variable(unit, "race") or unit.race
end
EoHS.set_unit_race = function(unit, race)
  if EoHS.custom_races[race] then
    EoHS.set_unit_variable(unit, "race", race)
    unit.race = EoHS.custom_races[race].base_race
  else
    EoHS.set_unit_variable(unit, "race")
    unit.race = race
  end
end

-- TODO: Rename this function to be in line with the other functions' style?
-- (e.g. the "all" is unnecessary and we could use something like "attributes" rather than "adjustments",
--   since this mostly is intended to overwrite things rather than tweaking them)
EoHS.update_all_type_adjustments = function(unit)
  local variables = EoHS.force_unit_variables(unit)
  if not variables.original_type then variables.original_type = unit.type end
  local original_type = variables.original_type
  local reference_type = original_type
  if variables.is_wizard and (reference_type == "Elvish Lady") then reference_type = EoHS.appropriate_wizard_unit_type("Elvish Lord", variables.wizard_level or unit.level) end
  local type_cfg = EoHS.unit_type_with_gender_and_variation(reference_type, unit.gender, unit.variation)
  unit.level = variables.wizard_level or type_cfg.level
  unit.type = original_type
  unit.advances_to = type_cfg.advances_to
  unit.alignment = type_cfg.alignment
  unit.cost = type_cfg.cost
  EoHS.set_unit_race(unit, type_cfg.race)
  variables.despair_ability = nil
  local type_in = function(list) for t in EoHS.comma_separated_values(list) do if original_type == t then return true end end; return false end
  
  local hitpoints = type_cfg.hitpoints
  local experience = type_cfg.experience
  local extra_effects_before_extra_attacks = {}
  local extra_attacks = {}
  local extra_effects = {}
  local make_effect = function(apply_to, contents, before_extra_attacks)
    contents.apply_to = apply_to
    table.insert(before_extra_attacks and extra_effects_before_extra_attacks or extra_effects, { "effect", contents })
  end
  -- We'd remove AMLA for units with special advancements, but we can't; fortunately it's overridden by the valid advances_to
  local default_melee_effects = {}
  local type_name_override = nil
  local force_zoc = nil
  
  local set_all_defenses = function (value)
    make_effect("defense", { replace = true, { "defense", { 
      flat=value, fungus=value, hills  =value, mountains =value,
      sand=value, forest=value, village=value, swamp_water=value, shallow_water=value, deep_water=value,
      cave=value, frozen=value, castle =value, unwalkable=value, }}})
  end
  
  if variables.is_crypt then
    variables.is_building = true
    force_zoc = false
    type_name_override = _"Crypt"
    variables.type_description_override = _"The crypt of a Lich. As long as this crypt exists, the lich cannot truly die."
    unit.advances_to = "null" -- doesn't work
    make_effect("remove_ability", { { "abilities", EoHS.macros.ABILITY_SUBMERGE } }) -- would be too cruel if it was effective at all, otherwise pointless/annoying
    
    set_all_defenses(80)
    make_effect("resistance", { replace = true, { "resistance", { blade = 40, pierce = 40, impact = 50, fire = 50, arcane = 60, cold = 40 }}, })
    make_effect("new_ability", { { "abilities", EoHS.abilities.regen_lesser } })
  end
  
  if variables.is_swarm_nest then
    variables.is_building = true
    force_zoc = false
    type_name_override = _"Swarm Nest"
    variables.type_description_override = _"A nest that spawns an AI-controlled unit onto each adjacent empty hex every turn."
    hitpoints = 95
    
    set_all_defenses(80)
    make_effect("resistance", { replace = true, { "resistance", { blade = 100, pierce = 80, impact = 100, fire = 150, arcane = 80, cold = 80 }}, })
    make_effect("new_ability", { { "abilities", EoHS.abilities.regen_lesser } })
    make_effect("image_mod", { replace = "~O(0)~BLIT(scenery/nest-full.png)" })
  end
  
  if variables.is_portal then
    variables.is_building = true
    force_zoc = false
    type_name_override = _"Portal"
    variables.type_description_override = _"A portal that allows all allied units to travel instantly to any other portal."
    EoHS.set_unit_race(unit, "mechanical")
    unit.profile = "unit_image"
    experience = 10000
    hitpoints = 60
    unit.level = 0
    make_effect("remove_attacks", {}, true)
    make_effect("movement", { set=0 })
    
    set_all_defenses(80)
    make_effect("resistance", { replace = true, { "resistance", { blade = 60, pierce = 40, impact = 60, fire = 40, arcane = 100, cold = 40 }}, })
    make_effect("new_ability", { { "abilities", EoHS.abilities.regen_lesser } })
    make_effect("image_mod", { replace = "~O(0)~BLIT(scenery/rock-cairn.png~BL(2)"..EoHS.constant_color_image_mod (EoHS.team_color (unit.side).mid).."~O(5))~BLIT(scenery/rock-cairn.png)" })
  end
  
  if variables.is_circle_of_protection then
    variables.is_building = true
    type_name_override = _"Circle of Protection"
    variables.type_description_override = _"A magic circle that defends a hex from all magic."
    EoHS.set_unit_race(unit, "EoHS_magic")
    
    hitpoints = 1
    unit.cost = 1
    set_all_defenses(100)
    make_effect("resistance", { replace = true, { "resistance", { blade = 100, pierce = 100, impact = 100, fire = 100, arcane = 100, cold = 100 }}, })
    
    --[[
    hitpoints = 50
    
    set_all_defenses(50)
    make_effect("resistance", { replace = true, { "resistance", { blade = 100, pierce = 100, impact = 100, fire = 100, arcane = 100, cold = 100 }}, })
    make_effect("new_ability", { { "abilities", { {"regenerate",{
      value = 12,
      id = "EoHS_circle_of_protection_regen",
      name = _"regenerates +12",
      description = _"The unit will heal itself 12 HP per turn. If it is poisoned, it will remove the poison instead of healing.",
      affect_self = true,
      poison = "cured",
    }} }} })]]
    make_effect("image_mod", { replace = "~O(0)" })
  end
  
  if variables.is_tower then
    variables.is_building = true
    force_zoc = false
    type_name_override = _"Tower"
    variables.type_description_override = _"A stately structure."
    EoHS.set_unit_race(unit, "mechanical")
    hitpoints = 48
    
    set_all_defenses(80)
    make_effect("resistance", { replace = true, { "resistance", { blade = 100, pierce = 100, impact = 100, fire = 100, arcane = 100, cold = 100 }}, })
    make_effect("image_mod", { replace = "~O(0)~BLIT(scenery/lighthouse.png)" })
  end
  
  if variables.is_building then
    experience = 10000
    unit.level = 0
    unit.profile = "unit_image"
    make_effect("remove_attacks", {}, true)
    make_effect("movement", { set=0 })
  end
  
  if variables.is_black_cat and (unit.type == "Rogue" or unit.type == "Assassin") then
    unit.profile = "unit_image"
    type_name_override = _"Black Cat"
    if unit.type == "Rogue" then
      unit.level = 0
      experience = 29
    else
      unit.level = 1
      experience = 50
    end
    force_zoc = (unit.level > 0)
    EoHS.set_unit_race(unit, "EoHS_cat")
    unit.cost = 18 + unit.level*11
    hitpoints = 22 + unit.level*13
    make_effect("movement", { set = 4 + unit.level })
    make_effect("remove_attacks", {}, true)
    make_effect("remove_ability", { { "abilities", EoHS.macros.ABILITY_SKIRMISHER } })
    table.insert(extra_attacks, {
      name = "claws",
      description = _"claws",
      icon = "attacks/claws-animal.png",
      type = "blade",
      range = "melee",
      damage = 4 + unit.level*3,
      number = 3,
    })
    make_effect("new_ability",  { { "abilities", EoHS.abilities.underfoot } })
    local wolf = EoHS.collapse_image_aggregate("image_modded", EoHS.image_aggregate_except("units/monsters/wolf.png", { x1=52,y2=50,relative_to_base_image = "units/monsters/wolf.png" })).."~CS(-115,-80,-30)~SCALE(45,45)"
    local bat = "units/undead/dreadbat-se-3.png~CROP(32,18,11,13)~TC(5,magenta)"
    make_effect("image_mod", { replace = "~O(0)~BLIT("..wolf..",13,14)~BLIT("..bat..",40,29)" })
  end
  
  if variables.is_skeletal_dragon then
    hitpoints = 216
    make_effect("attack", { increase_damage = 4, increase_attacks = 2 })
    make_effect("movement", { set=8 })
    
    -- as Skeleton
    make_effect("movement_costs", { replace = true, { "movement_costs", { 
      deep_water=3,
      shallow_water=2,
      reef=2,
      swamp_water=2,
      flat=1,
      sand=2,
      forest=2,
      hills=2,
      mountains=3,
      village=1,
      castle=1,
      cave=2,
      frozen=2,
      fungus=2,
    }}})
    make_effect("defense", { replace = true, { "defense", { 
      deep_water=90,
      shallow_water=80,
      reef=70,
      swamp_water=70,
      flat=60,
      sand=70,
      forest=50,
      hills=50,
      mountains=40,
      village=40,
      castle=40,
      cave=60,
      frozen=70,
      fungus=40,
    }}})
    -- Leave the normal (better than Skeleton) resistances
    --[[make_effect("resistance", { replace = true, { "resistance", {
      blade=60,
      pierce=40,
      impact=120,
      fire=120,
      cold=40,
      arcane=150,
    }}})]]
    
    --make_effect("new_ability", { { "abilities", {{ "dummy", {name=_"",description=_""} }} } })
  end
  
  if variables.is_swarm and (original_type == "Tentacle of the Deep") then
    unit.level = 0
  end
  
  local special_ids_found = {}
  if variables.is_summon then
    if (original_type == "Chocobone") then
      unit.cost = 24
      unit.advances_to = "Death Knight"
      experience = 82
    elseif (original_type == "Death Knight") then
      unit.cost = 48
      make_effect("movement", { set = 9 })
      make_effect("attack", { name = "battle axe", increase_damage = -2 })
      table.insert(extra_attacks, {
        name = "spear",
        description = _"spear",
        type = "pierce",
        range = "melee",
        damage = 14,
        number = 2,
        { "specials", EoHS.macros.WEAPON_SPECIAL_CHARGE },
      })
    end
    
    if (original_type ==       "Wolf") then experience = 30; unit.advances_to = "Great Wolf"; unit.cost = 15 end
    if (original_type == "Great Wolf") then experience = 65; unit.advances_to =   "Direwolf"; make_effect("attack", { increase_damage = 2 }) end
    if (original_type ==   "Direwolf") then                                                   make_effect("attack", { increase_damage = 2 }) end
    
    if (original_type == "Giant Scorpion") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 19
        unit.advances_to = original_type
        experience = 34
      else
        type_name_override = _"Plated Scorpion"
        unit.level = 2
        unit.cost = 29
        experience = 100
        hitpoints = hitpoints + 10
        make_effect("resistance", { replace = true, { "resistance", { blade = 70, pierce = 70, fire = 120, arcane = 110, cold = 100 }}, })
        make_effect("attack", { name = "pincers", increase_damage = 2 })
        make_effect("attack", { name = "sting", increase_attacks = 1 })
        make_effect("image_mod", {
          { "color_palette", {
            EoHS_giant_scorpion_palette = "394960,8796b3,435778,56657c,8c9bb2,6b7b94,6b7c98,7686a0,00274f,313f5a,273649,131a24,1a2835,39455f,2f3241,31415b,92acc7,7994af,8199bd,576276,596d88,717b9e,2e3b5b,5f6d88,b5b0ce,9b98b7,5f607f,b1add0,8384a3,8180a2,414c5e,737492,384c71,1d2c49",
          }},
          { "color_range", {
            id = "EoHS_bigger_scorpion_range",
            rgb = "921e00,ffe267,000000",
          }},
          add = "~SCALE(84,84)~RC(EoHS_giant_scorpion_palette>EoHS_bigger_scorpion_range)",
        })
      end
    end
    
    if (original_type == "Gryphon") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 25
        unit.advances_to = original_type
        experience = 74
      else
        type_name_override = _"Dire Gryphon"
        unit.level = 3
        unit.cost = 48
        experience = 150
        hitpoints = hitpoints + 18
        make_effect("attack", { name = "claws", increase_damage = 4 })
        make_effect("movement", { increase = 1 })
        make_effect("image_mod", { add = "~CS(0,-20,-60)" })
      end
    end
    
    if (original_type == "Water Serpent") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 23
        unit.advances_to = original_type
        experience = 68
      else
        type_name_override = _"Slipstream Serpent"
        unit.level = 3
        unit.cost = 42
        experience = 150
        hitpoints = hitpoints + 12
        make_effect("attack", { name = "fangs", increase_attacks = 1, increase_damage = 1 })
        make_effect("movement", { increase = 1 })
        make_effect("image_mod", { add = "~CS(-60,-60,0)" })
      end
    end
    
    if (original_type == "Sea Serpent") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 26
        unit.level = 2
        hitpoints = hitpoints - 9
        unit.advances_to = original_type
        experience = 88
      else
        type_name_override = _"Sea Behemoth"
        unit.cost = 58
        hitpoints = hitpoints + 9
        make_effect("attack", { name = "fangs", increase_damage = 7 })
        make_effect("movement", { increase = 2 })
        make_effect("image_mod", { add = "~CS(-30,-70,-90)" })
        local name = _"open water only"
        local description = _"This attack can be used in deep water, shallow water, and coastal reefs, but not in river ford, swamp, or land terrains."
        table.insert(extra_attacks, {
          name = "gigantic splash",
          description = _"gigantic splash",
          icon = "attacks/waterspray.png",
          type = "impact",
          range = "ranged",
          damage = 8,
          number = 3,
          {"specials",{
            { "disable", {
              name = name,
              description = description,
              name_inactive = name,
              description_inactive = description,
              {"filter_self",{
                {"not",{
                  {"filter_location",{
                    terrain="Ww*,Wo*",
                    {"not",{ terrain="Wwf" }}
                  }}
                }}
              }}
            }}
          }}
        })
      end
    end
    
    if type_in("Ghost,Shadow,Nightgaunt,Wraith,Spectre") then
      unit.cost = type_cfg.cost - 4
    end
    if type_in("Wose,Elder Wose,Ancient Wose") then
      unit.cost = type_cfg.cost - 2
    end
    if type_in("Drake Fighter,Drake Warrior,Drake Blademaster") then
      unit.cost = type_cfg.cost + 3
      if original_type == "Drake Fighter" then
        type_name_override = _"Arctic Drake"
      elseif original_type == "Drake Warrior" then
        type_name_override = _"Arctic Warrior"
      elseif original_type == "Drake Blademaster" then
        type_name_override = _"Arctic Blademaster"
      end
      make_effect("image_mod", {
        { "color_palette", {
          EoHS_drake_fighter_palette = "86ac53,fde9f1,fde6ef,fadb85,f7df8e,f6db84,dfc799,c7d95e,c3d355,c1d553,c19057,a2c157,9dba50,99b94e,7ca448,679345,5e8d44,57624d,573d2d,53844a,4c5742,4a5640,487a3f,3c513e,324634,2d4331,242e12,1c250d,151f06,100506",
        }},
        { "color_range", {
          id = "EoHS_blue_drake_range",
          rgb = "8888ff,ffffff,000000",
        }},
        add = "~RC(EoHS_drake_fighter_palette>EoHS_blue_drake_range)",
      })
      make_effect("resistance", { replace = true, { "resistance", { cold = 80, arcane = 90, }}, })
      -- I didn't originally intend to change its snow movement/defense, but the "arctic" theme requires me to (and I have nothing against it)
      make_effect("movement_costs", { replace = true, { "movement_costs", { frozen = 1, }}, })
      make_effect("defense",        { replace = true, { "defense",        { frozen = 60, }}, })
    end
    
    if original_type == "Fire Dragon" then
      type_name_override = _"Dragon"
      make_effect("remove_attacks", { range="ranged" }, true)
      make_effect("remove_ability", { { "abilities", EoHS.macros.ABILITY_LEADERSHIP } })
      make_effect("attack", {
        name = "bite",
        { "set_specials", {
          mode = "append",
          { "dummy", {
            id = "EoHS_devour",
            name = _"devour",
            description = _"Whenever this unit kills another unit with this attack, this unit is healed by half the killed unit's max hitpoints, rounded down."
          }},
        }},
      })
      
      local dragon = EoHS.get_fake_subtag(variables, "dragon")
      hitpoints = dragon.hitpoints or 1 -- to satisfy the prototype
      unit.alignment = dragon.alignment
      make_effect("movement", { set = dragon.moves })
      
      local resistances = function(r)
        make_effect("resistance", { replace = true, { "resistance", r }, })
      end
      local defenses = function(r)
        make_effect("defense", { replace = true, { "defense", r }, })
      end
      local movement_costs = function(r)
        make_effect("movement_costs", { replace = true, { "movement_costs", r }, })
      end
      
      local most_terrains = {
        deep_water=1,
        shallow_water=1,
        reef=1,
        swamp_water=1,
        flat=1,
        sand=1,
        forest=1,
        hills=1,
        mountains=1,
        village=1,
        castle=1,
        frozen=1,
        unwalkable=1,
      }
      local d,m = {},{}
      if dragon.movetype == "fly" then
        for k in pairs(most_terrains) do d[k] = 50; m[k]=1 end
      elseif dragon.movetype == "walk" then
        -- drakefoot
        d = {
          unwalkable=100,
          deep_water=100,
          shallow_water=80,
          reef=70,
          swamp_water=80,
          flat=70,
          sand=60,
          forest=60,
          hills=60,
          mountains=60,
          village=60,
          castle=60,
          cave=70,
          frozen=80,
          fungus=60,
        }
        m = {
          unwalkable=99,
          deep_water=99,
          shallow_water=3,
          reef=2,
          swamp_water=3,
          flat=1,
          sand=1,
          forest=2,
          hills=1,
          mountains=1,
          village=1,
          castle=1,
          cave=2,
          frozen=3,
          fungus=2,
        }
      end
      
      dragon.breath_names = nil
      local make_breath = function(name, description, dam_type, specials)
        dragon.breath_names = (dragon.breath_names and dragon.breath_names.."," or "")..name
        if dragon.breath_cth == "marksman" then table.insert(specials, 1, EoHS.macros.WEAPON_SPECIAL_MARKSMAN[1]) end
        if dragon.breath_cth == "magical" then table.insert(specials, 1, EoHS.macros.WEAPON_SPECIAL_MAGICAL[1]) end
        table.insert(specials, { "dummy", {
          id = "EoHS_dragon_breath_info",
          name = _"area option",
          description = EoHS.substitute(_"The dragon may use this attack, at half damage, to strike every unit in a cone $1| hexes long and $2| degrees wide. This action costs $3| mana.", {dragon.breath_length, dragon.breath_spread*2, dragon.breath_mana})
        }})
        table.insert(extra_attacks, {
          name = name,
          description = description,
          icon = "attacks/fire-breath-drake.png",
          type = dam_type,
          range = "ranged",
          damage = dragon.breath_damage,
          number = dragon.breath_swings,
          {"specials",specials}
        })
      end
      local original_palette = "fff9d5,987b8c,aecacc,ffe39f,3d5a4b,ab718d,ff8b19,d26a2c,f6e795,ffc946,ffa32c,d9524f,b41056,b83d00,872819,c64e32,c06d01,640f46,631205,724149,430027"
      local palette_id = ""
      local rgb_funcs = {}
      local rgbonus = function(c,bonus)
        if (c==0) or (c==255) or (bonus==0) or (bonus==nil) then return c end
        return math.floor(0.5+((math.atan(math.tan(((c/255)-0.5)*math.pi)+(bonus*math.pi/255))/math.pi)+0.5)*255)
      end
      local rgb_map = function(rgb,func)
        rgb.r = func(rgb.r)
        rgb.g = func(rgb.g)
        rgb.b = func(rgb.b)
      end
      local rgbonize = function(rgb,r,g,b)
        rgb.r = rgbonus(rgb.r,r)
        rgb.g = rgbonus(rgb.g,g)
        rgb.b = rgbonus(rgb.b,b)
        EoHS.assert(rgb.r>=0)
        EoHS.assert(rgb.r<=255)
        EoHS.assert(rgb.g>=0)
        EoHS.assert(rgb.g<=255)
        EoHS.assert(rgb.b>=0)
        EoHS.assert(rgb.b<=255)
      end
      local make_mod = function(id, rgb_func)
        table.insert(rgb_funcs, rgb_func)
        palette_id = palette_id..id
      end
      if dragon.type == "fire" then
        make_breath("fire breath", _"fire breath", "fire", {})
      elseif dragon.type == "acid" then
        make_mod("acid", function(c) c.r,c.g,c.b=c.g,c.r,c.b end)
        make_breath("acid breath", _"acid breath", "fire", {EoHS.macros.WEAPON_SPECIAL_POISON[1]})
        resistances({ fire = 60, cold = 100 })
      elseif dragon.type == "lightning" then
        make_mod("lightning", function(c) c.r,c.g,c.b=(3*c.r+c.g)/4,(2*c.r+2*c.g)/4,c.b/2 end)
        make_breath("lightning breath", _"lightning breath", "lightning", {EoHS.macros.WEAPON_SPECIAL_SLOW[1]})
        resistances({ fire = 100, cold = 100, lightning = 0 })
      elseif dragon.type == "ice" then
        make_mod("ice", function(c)
          c.r,c.g,c.b=c.b,c.g,c.r
          rgbonize(c,100,100,100)
        end)
        make_breath("cold breath", _"cold breath", "cold", {})
        make_breath("ice breath", _"ice breath", "blade", {})
        resistances({ blade = 90, pierce = 80, impact = 110, fire = 150, cold = 0 })
        m.frozen = 1
        d.frozen = math.min(60, d.frozen or 100)
      elseif dragon.type == "water" then
        make_mod("water", function(c)
          c.r,c.g,c.b=c.b,c.g,c.r
          rgbonize(c,-50,0,0)
        end)
        make_breath("water breath", _"water breath", "impact", {})
        resistances({ blade = 110, pierce = 110, impact = 60, fire = 30, cold = 100 })
        m.shallow_water = 1
        m.swamp_water   = math.min( 2, m.swamp_water   or  99)
        m.deep_water    = 1
        m.reef          = 1
        d.shallow_water = math.min(60, d.shallow_water or 100)
        d.swamp_water   = math.min(60, d.swamp_water   or 100)
        d.deep_water    = math.min(60, d.deep_water    or 100)
        d.reef          = math.min(60, d.reef          or 100)
      elseif dragon.type == "spirit" then
        make_mod("spirit", function(c)
          local avg = (c.g+c.b+c.r)/3
          local fix=function(q) return (q>avg) and math.max(avg,q-30) or math.min(avg,q+30) end
          c.r,c.g,c.b=fix(c.g),fix(c.b),fix(c.r)
          rgbonize(c,avg-100,avg-100,avg-100)
        end)
        make_breath("spirit breath", _"spirit breath", "arcane", {EoHS.macros.WEAPON_SPECIAL_PLAGUE[1]})
        resistances({ blade = 110, pierce = 110, impact = 110, fire = 60, cold = 60, arcane = 0 })
      end
      defenses(d); movement_costs(m)
      
      -- make breath_cs before abilities (abilities don't affect breath type)
      local cs_rgb = {r=210,g=106,b=44}
      for i,f in ipairs(rgb_funcs) do f(cs_rgb) end
      dragon.breath_cs = "~CS("..(cs_rgb.r-128)..","..(cs_rgb.g-128)..","..(cs_rgb.b-128)..")"
      
      if dragon.ability == "leadership" then
        make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_LEADERSHIP }})
      elseif dragon.ability == "despair" then
        make_mod("despair", function(c) rgbonize(c,-50,-100,-50) end)
        make_effect("new_ability", { { "abilities", EoHS.abilities.despair } })
        variables.despair_ability = true
      elseif dragon.ability == "protection" then
        make_mod("protection", function(c)
          local avg = (c.g+c.b+c.r)/3
          if avg < 100 then
            if (dragon.type == "fire") or (dragon.type == "acid") then c.r,c.g,c.b=c.b,c.r,c.g else c.r,c.g,c.b=c.g,c.b,c.r end
          end
          --local w = 100-math.min(100,avg)
          --rgbonize(c,-w,w,0)
        end)
        make_effect("new_ability", { { "abilities", EoHS.abilities.protection } })
      elseif dragon.ability == "light_control" then
        make_effect("new_ability", { { "abilities", EoHS.abilities.light_control } })
        variables.light_control_ability = true
        if dragon.alignment == "lawful" then
          make_mod("illuminates", function(c)
            rgb_map(c, function(q) return 255-math.floor((255-q)*0.9) end)
            rgbonize(c,100,80,60)
          end)
          --make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_ILLUMINATES } })
        elseif dragon.alignment == "chaotic" then
          make_mod("deluminates", function(c)
            rgb_map(c, function(q) return math.floor(q*0.9) end)
            rgbonize(c,-100,-80,-60)
          end)
          --make_effect("new_ability", { { "abilities", EoHS.abilities.deluminates } })
        else
          make_mod("twilight", function(c)
            rgb_map(c, function(q) return math.floor(13.25+q*0.9) end)
            rgbonize(c,100-c.r,100-c.g,100-c.b)
          end)
          --make_effect("new_ability", { { "abilities", EoHS.abilities.twilight } })
        end
      end
      
      palette_id = "EoHS_dragon_"..palette_id.."_palette"
      make_effect("image_mod", {
        { "color_palette", {
          EoHS_dragon_palette = original_palette,
          [palette_id] = string.gsub(original_palette, "(..)(..)(..)(,?)", function(rs,gs,bs,comma)
            local rgb={}
            rgb.r,rgb.g,rgb.b = tonumber(rs,16),tonumber(gs,16),tonumber(bs,16)
            for i,f in ipairs(rgb_funcs) do f(rgb) end
            return string.format("%.2x%.2x%.2x",rgb.r,rgb.g,rgb.b)..comma
          end)
        }},
        add = "~PAL(EoHS_dragon_palette>"..palette_id..")",
      })
    end
  end
  
  if variables.is_wizard then
    local is_a_normal_wizard_type = true
    --EoHS.debug(unit)
    local skills = EoHS.get_unit_skillset(unit)
    
    local special_wizard_advances_to = EoHS.appropriate_wizard_unit_type(original_type, unit.level + 1)
    if special_wizard_advances_to then
      unit.advances_to = special_wizard_advances_to
    elseif (not unit.advances_to) or (unit.advances_to == "null") or (unit.level < type_cfg.level) then
      unit.advances_to = original_type
    end
    unit.cost = 15 + unit.level*math.min(5,unit.level)*8
    unit.description = EoHS.rules
    experience = EoHS.wizard_max_experience(unit.level)
    
    --[[if (original_type == "Mage") then
      make_effect("remove_attacks", { name="missile" })
    end
    if type_in("Red Mage,Arch Mage,Great Mage") then
      make_effect("remove_attacks", { name="fireball" })
    end
    if (original_type == "Lich") then
      make_effect("remove_attacks", { name="chill tempest" })
      make_effect("remove_attacks", { name="shadow wave" })
    end]]
    if not variables.spiritform then make_effect("remove_attacks", { range="ranged" }, true) end
    if original_type == "Elvish Lady" then
      unit.advances_to = original_type
      for attack in wml.child_range(type_cfg, "attack") do
        if attack.range == "melee" then
          table.insert(extra_attacks, attack)
        end
      end
      if unit.level >= 3 then
        type_name_override = _"Elvish High Lady"
      end
    end
    
    local make_attack = function(skill_name, upgrade_array, bonus, attack)
      local skill = EoHS.skillset_realm_rank(skills, skill_name)
      if skill > 0 then
        local upgrade_total = math.max(0, math.min(skill, unit.level)) + 2
        if skills.focused_study then upgrade_total = upgrade_total - 1 end
        local upgrade_array_index = math.min(#upgrade_array, upgrade_total)
        local excess = math.max(0, upgrade_total - upgrade_array_index)
        
        attack.range = "ranged"
        attack.damage = upgrade_array[upgrade_array_index][1] + math.floor(excess * bonus)
        if skills.focused_study then attack.damage = math.floor((attack.damage*8+5)/10) end
        attack.number = upgrade_array[upgrade_array_index][2]
        table.insert(attack, { "specials", EoHS.macros.WEAPON_SPECIAL_MAGICAL })
        table.insert(extra_attacks, attack)
      end
    end
    make_attack("evocation",
      {{ 6,1},{ 6,2},{ 7,3},{ 8,4}}, 4,
      {
        name = "EoHS_evocation_skill_ranged_attack",
        description = wesnoth.textdomain("wesnoth-units")("fireball"),
        icon = "attacks/fireball.png",
        type = "fire",
      }
    )
    make_attack("nature_magic",
      {{ 3,2},{ 4,3},{ 5,4},{ 6,5}}, 3,
      {
        name = "EoHS_nature_magic_skill_ranged_attack",
        description = wesnoth.textdomain("wesnoth-units")("faerie fire"),
        icon = "attacks/faerie-fire.png",
        type = "arcane",
      }
    )
    make_attack("necromancy",
      {{ 6,1},{ 6,2},{10,2},{10,3}}, 5,
      {
        name = "EoHS_necromancy_skill_ranged_attack",
        description = wesnoth.textdomain("wesnoth-units")("chill wave"),
        icon = "attacks/iceball.png",
        type = "cold",
      }
    )
    
    hitpoints = EoHS.wizard_max_hitpoints(unit.level)
    if same_line(reference_type, "Red Mage") then
      make_effect("resistance", { replace=true, { "resistance", { fire = 100, arcane = 100, }} })
      table.insert(default_melee_effects, {
        increase_attacks = 1,
        increase_damage  = -1 + math.max(unit.level-4, 0),
      })
    elseif same_line(reference_type, "Elvish Lord") then
      unit.cost = unit.cost + 3
      hitpoints = math.floor((hitpoints*9+5)/10)
      if unit.level < 2 then table.insert(default_melee_effects, { increase_damage = 2*unit.level - 6, })
      else table.insert(default_melee_effects, { increase_damage = (unit.level - type_cfg.level) - 2, }) end
    elseif same_line(reference_type, "Dwarvish Runesmith") then
      unit.cost = unit.cost + 4
      hitpoints = math.floor((hitpoints*21+10)/20)
      if unit.level < 2 then
        make_effect("resistance", { replace=true, { "resistance", { blade=80-10*unit.level, pierce=80, impact=80 }} })
        table.insert(default_melee_effects, { increase_damage = 2*unit.level - 8, })
      elseif unit.level == 2 then
        table.insert(default_melee_effects, { increase_damage = -2, })
      elseif unit.level == 3 then
        table.insert(default_melee_effects, { increase_damage = -5, })
      elseif unit.level == 4 then
        table.insert(default_melee_effects, { increase_damage = -10, })
      else
        table.insert(default_melee_effects, { increase_damage = 2*unit.level - 18, })
      end
    elseif same_line(reference_type, "Troll Shaman") then
      unit.cost = unit.cost + 7
      hitpoints = math.floor((hitpoints*23+10)/20)
      table.insert(default_melee_effects, { increase_damage = 2*unit.level - 2, })
    elseif same_line(reference_type, "Silver Mage") then
      type_name_override = _"Rogue Mage"
      unit.alignment = "chaotic"
      unit.cost = unit.cost + 2
      hitpoints = math.floor((hitpoints*19+10)/20)
      table.insert(default_melee_effects, {
        increase_attacks = (unit.level > 1) and 1 or 0,
        increase_damage  = unit.level - 3,
      })
      make_effect("remove_ability", { { "abilities", EoHS.macros.ABILITY_TELEPORT } })
      if unit.level > 1 then make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_SKIRMISHER } }) end
      -- elusivefoot
      make_effect("movement_costs", { replace = true, { "movement_costs", { 
        shallow_water=2,
        reef=2,
        swamp_water=2,
        flat=1,
        sand=2,
        forest=2,
        hills=2,
        mountains=3,
        village=1,
        castle=1,
        cave=2,
        frozen=2,
        fungus=2,
      }}})
      make_effect("defense", { replace = true, { "defense", { 
        shallow_water=60,
        reef=50,
        swamp_water=60,
        flat=40,
        sand=60,
        forest=30,
        hills=30,
        mountains=30,
        village=30,
        castle=30,
        cave=50,
        frozen=60,
        fungus=30,
      }}})
      make_effect("resistance", { replace = true, { "resistance", {
        blade=130,
        pierce=120,
        impact=120,
        fire=100,
        cold=100,
        arcane=100,
      }}})
    elseif same_line(reference_type, "Mermaid Enchantress") then
      table.insert(default_melee_effects, {
        increase_attacks = 1,
        increase_damage  = -1 + math.max(2*(unit.level-3), 0),
      })
    elseif same_line(reference_type, "Dark Adept") then
      hitpoints = math.floor((hitpoints*21+10)/20)
      make_effect("resistance", { replace=true, { "resistance", { arcane = 100, }} })
      unit.cost = unit.cost - 2
      table.insert(default_melee_effects, { increase_damage  = math.max(0, unit.level-3), })
    elseif same_line(reference_type, "Saurian Augur") then
      unit.cost = unit.cost - 1
      hitpoints = math.floor((hitpoints*8+5)/10)
      if unit.level > 1 then
        table.insert(default_melee_effects, {
          increase_attacks = 1,
          increase_damage  = unit.level-2,
        })
      end
    elseif same_line(reference_type, "Mermaid Priestess") or same_line(reference_type, "White Mage") then
      unit.cost = unit.cost + 3
      make_effect("resistance", { replace=true, { "resistance", { arcane = 100, }} })
      hitpoints = math.floor((hitpoints*9+5)/10)
      if unit.level < 2 then
        make_effect("remove_ability", { { "abilities", EoHS.macros.ABILITY_CURES } })
        make_effect("new_ability"   , { { "abilities", EoHS.macros.ABILITY_HEALS } })
                             table.insert(default_melee_effects, { increase_damage = unit.level - 2, }) end
      if unit.level > 3 then table.insert(default_melee_effects, { increase_damage = unit.level - 3, }) end
    elseif same_line(reference_type, "Lich") then
      unit.max_attacks = 2
      -- TODO: should liches retain their variant HP total?
      unit.cost = unit.cost + 12
      -- Invisibility undercuts the drama of a wizard, and this usually-irrelevant ability clutters the ability list.
      make_effect("remove_ability", {
        { "abilities", EoHS.macros.ABILITY_SUBMERGE },
      })
      table.insert(default_melee_effects, {
        increase_damage = unit.level - 3,
      })
      --[[do
        local upgrade_array = {{1,1},{4,1},{4,2}}
        local bonus = 3
        local upgrade_total = math.min(0, unit.level - 3)
        local upgrade_array_index = math.min(#upgrade_array, upgrade_total)
        local excess = math.max(0, upgrade_total - upgrade_array_index)
        
        if unit.level > 3 then
          make_effect("attack", {
            name = "chill tempest",
            increase_damage = upgrade_array[upgrade_array_index][1] + math.floor(excess * bonus),
            increase_attacks = upgrade_array[upgrade_array_index][2],
          })
          make_effect("attack", {
            name = "shadow wave",
            increase_damage = math.floor((upgrade_array[upgrade_array_index][1] + excess * bonus) * 0.75),
            increase_attacks = upgrade_array[upgrade_array_index][2],
          })
        end
      end]]
    else
      is_a_normal_wizard_type = false
      hitpoints = type_cfg.hitpoints
      
      local highest_melee_damage = 0
      local best_melee = 0
      local best_other = 0
      local damages_found = {}
      for attack in wml.child_range(type_cfg, "attack") do
        if attack.range == "melee" then
          damages_found [attack.damage] = true
          highest_melee_damage = math.max (highest_melee_damage, attack.damage)
          best_melee = math.max(best_melee, attack.damage*attack.number)
        else
          best_other = math.max(best_other, attack.damage*attack.number)
        end
      end
      
      if best_other < best_melee*2 then
        -- Awkward situation: using an effect that decreases damage by a percentage
        -- has unfavorable rounding, so we want to modify each attack individually,
        -- so we can use custom rounding. However, there is no way to select a specific attack!
        -- Usually, attacks all have different "name" values, but this isn't guaranteed,
        -- and so we can't filter on name.
        -- Fortunately, the only thing that differs between the effects is based on
        -- the attack's original damage, so we can filter based on DAMAGE instead.
        -- We still need to be careful of two things:
        -- the damage-specific effects must only apply to melee attacks, 
        -- and they must apply in ascending order, so that they don't hit the same attack twice.

        for damage = 1, highest_melee_damage do
          -- Only create effects for actual attacks, to be somewhat less suboptimal if someone makes a 10000 damage attack or whatever
          if damages_found [damage] then
            make_effect ("attack", {
              damage = damage,
              range = "melee",
              increase_damage = -math.ceil((damage*(best_melee*2-best_other) - best_melee*2)/(best_melee*4)),
            })
          end
        end
      end
      table.insert(default_melee_effects, {
        increase_damage = unit.level - type_cfg.level,
      })
    end
    
    if is_a_normal_wizard_type and (original_type ~= "Lich") then
      make_effect("resistance", { replace=false, { "resistance", {
        fire   = math.min(0, 10 - math.min(EoHS.skillset_realm_rank(skills, "evocation"   ), unit.level, 4) * 10),
        cold   = math.min(0, 10 - math.min(EoHS.skillset_realm_rank(skills, "necromancy"  ), unit.level, 4) * 10),
        arcane = math.min(0, 10 - math.min(EoHS.skillset_realm_rank(skills, "nature_magic"), unit.level, 4) * 10),
      }} })
      
      if not variables.is_apprentice then
        unit.alignment = "neutral"
        if skills.dunefolk then
          unit.alignment = "liminal"
          make_effect("new_ability", { { "abilities", {
            {"leadership",{
              id="EoHS_liminal_compensation",
              add=-8,
              affect_self=true,
              { "filter_weapon", {
                range=(type_cfg.alignment == "liminal") and "ranged" or nil,
              }},
            }}
          }}})
        else
          if skills.military_commander and not skills.petty_necromancer  then unit.alignment = "lawful"  end
          if skills.petty_necromancer  and not skills.military_commander then unit.alignment = "chaotic" end
        end
      end
    end
    
    --[[if skills.mentor then
      make_effect("resistance", { replace=false, { "resistance", {
        arcane = -40,
        fire   = -40,
        cold   = -40,
      }} })
    end]]
    if skills.dwarvish_alliance then
      make_effect("resistance", { replace=false, { "resistance", {
        blade  = -20,
        impact = -20,
        pierce = -20,
      }} })
    end
    if skills.traveler then
      make_effect("movement", { increase=1 })
      make_effect("defense", { replace=false, { "defense", {
        deep_water = -10,
        shallow_water = -10,
        reef = -10,
        swamp_water = -20,
        forest = skills.elvish_alliance and 0 or -10,
        sand = skills.dunefolk and 0 or -10,
        frozen = -20,
      }} })
      make_effect("movement_costs", { replace=false, { "movement_costs", {
        shallow_water = -1,
        swamp_water = -1,
        sand = -1,
        hills = -1,
        mountains = -1,
        cave = -1,
        frozen = -2,
      }} })
    end
    if skills.military_commander then
      make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_LEADERSHIP }})
    end
    if skills.rascally_friends then
      make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_SKIRMISHER } })
    end
    if skills.dunefolk then
      make_effect("defense", { replace=false, { "defense", { sand = -20, }} })
      make_effect("movement_costs", { replace=false, { "movement_costs", { sand = -1, }} })
    end
    if skills.elvish_alliance then
      make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_CURES } })
      make_effect("defense", { replace=false, { "defense", { forest = -20, }} })
      make_effect("movement_costs", { replace=false, { "movement_costs", { forest = -1, }} })
    end
    if skills.orcish_mercenaries then 
      table.insert(default_melee_effects, { increase_damage = 2, })
    end
    if skills.petty_necromancer then
      hitpoints = math.floor((hitpoints*12+5)/10)
    end
    if skills.petty_necromancer and (original_type ~= "Lich") then -- I feel like Liches shouldn't default to having plague, since they don't normally
      -- hack - don't duplicate plague... TODO a better way to do this
      special_ids_found.plague = true
      table.insert(default_melee_effects, {
        set_description = wesnoth.textdomain("wesnoth-units")("plague staff"),
        set_icon = "attacks/staff-plague.png", -- Won't work until 1.11
        { "set_specials", {
          mode = "append",
          EoHS.macros.WEAPON_SPECIAL_PLAGUE[1],
        }},
      })
    end
    
    if EoHS.appearance_is_customizable(unit) then
      unit.profile = "unit_image"
    end
    
    if EoHS.get_variable("settings_inited") and EoHS.get_wizard_setting(unit, "can_recruit") and not EoHS.no_alliances then
      local current_recruits = {}
      for recruit in EoHS.comma_separated_values(unit.extra_recruit) do
        current_recruits[recruit] = true
      end
      local needed_recruits = {}
      local need = function(list)
        for recruit in EoHS.comma_separated_values(list) do
          table.insert(needed_recruits, recruit)
        end
      end
      for i,alliance in ipairs(EoHS.skills.alliances) do
        if skills[alliance.id] then need(alliance.recruit) end
      end
      if skills.dwarvish_alliance and skills.summon_gryphon then need("Gryphon Rider") end
      --[[for i,recruit in ipairs(needed_recruits) do
        if not current_recruits[recruit] then
          if unit.extra_recruit == "" then
            unit.extra_recruit = recruit
          else
            unit.extra_recruit = unit.extra_recruit..","..recruit
          end
        end
      end]]
      -- Since we now have recruit removal (by becoming a lich), give up on doing the above thing to be compatible with scenario extra_recruit
      unit.extra_recruit = table.concat(needed_recruits, ",")
    end
  end
    
  local literal_variables = EoHS.get_subtag(unit, "variables")
  local num_soul_bind_abilities = 0
  local intimidate = false
  local harms_strength = 0
  local mana_income -- Aggregating the mana income bonus here is a little odd, but since we're doing all the other Soul Bind things here...
  local images
  local num_souls
  local next_extra_attack_id = 2
  local soul_bind_extra_attacks = {}
  for soul in wml.child_range(literal_variables, "EoHS_bound_soul") do
    num_souls = (num_souls or 0) + 1
    images = (images or "").."BeginSoulImage"..soul.image.."EndSoulImage"
    hitpoints = hitpoints + soul.max_hitpoints
    if soul.intimidate then intimidate = true end
    harms_strength = math.max(harms_strength, soul.harms_strength)
    if soul.mana_income then mana_income = (mana_income or 0) + soul.mana_income end
    for i,subtag in ipairs(soul) do
      if subtag[1] == "abilities" then
        make_effect("new_ability", { subtag })
        local ability_ids_found = {}
        for i,ability in ipairs(subtag[2]) do
          if not ability_ids_found[ability[2].id] then
            ability_ids_found[ability[2].id] = true
            num_soul_bind_abilities = num_soul_bind_abilities + 1
          end
        end
      end
      if subtag[1] == "stacking_specials" then
        local set_specials_contents = EoHS.deep_copy(subtag[2])
        EoHS.remove_subtags(set_specials_contents, "*", function(s)
          local has_already = special_ids_found[s.id]
          special_ids_found[s.id] = true
          return has_already
        end)
        set_specials_contents.mode = "append"
        table.insert(default_melee_effects, {
          { "set_specials", set_specials_contents },
        })
      end
      if subtag[1] == "non_stacking_specials" then
        for i,special in ipairs(subtag[2]) do
          if not special_ids_found[special[2].id] then
            special_ids_found[special[2].id] = true
            num_soul_bind_abilities = num_soul_bind_abilities + 1
            local modify_attack = function (attack)
              if attack.range == "melee" then
                local this_attack_non_stacking_specials = {}
                local specials = EoHS.get_subtag(attack, "specials")
                if specials then for i,special2 in ipairs(specials) do
                  if special2[2].id == special[2].id then return end
                  local include, stacks = EoHS.soul_bind_analyze_special (special2)
                  if include and not stacks then
                    table.insert(this_attack_non_stacking_specials, special2)
                  end
                end end
                
                if special[2].id == "drains" and not this_attack_non_stacking_specials[1] then
                  -- It's always good, so put it on the default attack
                  make_effect("attack", { name=attack.name, { "set_specials", { mode = "append", special } } })
                else
                  local new_attack = EoHS.deep_copy(attack)
                  new_attack.name = attack.name.."_"..next_extra_attack_id
                  local new_specials = EoHS.force_subtag(new_attack, "specials")
                  EoHS.filter(new_specials, function (special2)
                    local include, stacks = EoHS.soul_bind_analyze_special (special2)
                    if include and not stacks then
                      return false
                    end
                    return true
                  end)
                  table.insert(new_specials, special)
                  table.insert(soul_bind_extra_attacks, new_attack)
                end
              end
            end

            for attack in wml.child_range(type_cfg, "attack") do
              modify_attack(attack)
            end
            for i,attack in ipairs(extra_attacks) do
              modify_attack(attack)
            end
          end
        end
      end
    end
  end
  for index, attack in ipairs (soul_bind_extra_attacks) do
    table.insert (extra_attacks, attack)
  end
  if intimidate then
    num_soul_bind_abilities = num_soul_bind_abilities + 1
    make_effect("new_ability", { { "abilities", EoHS.abilities.intimidate }})
  end
  if harms_strength > 0 then
    num_soul_bind_abilities = num_soul_bind_abilities + 1
    make_effect("new_ability", { { "abilities", { {"dummy",{
      name=EoHS.substitute(_"harms -$1|", {harms_strength}),
      description=EoHS.substitute(_"At the end of this unit's turn, each adjacent enemy loses $1| HP. This can't reduce a unit's HP below 1.", {harms_strength}),
    }} }}})
    EoHS.set_unit_variable(unit, "harms_strength", harms_strength)
  else
    EoHS.set_unit_variable(unit, "harms_strength", nil)
  end
  EoHS.set_unit_variable(unit, "soul_bind_mana_income", mana_income)
  EoHS.set_unit_variable(unit, "soul_bind_images", images)
  EoHS.set_unit_variable(unit, "souls_bound", num_souls)
  if num_soul_bind_abilities >= 5 then
    EoHS.earn_achievement(unit.side, "soul_bound_a_lot")
  end

  
  local original_type_cfg = type_cfg
  type_cfg = nil -- To make sure we don't use it after this, where it could be a bug (look at the original form explicitly if you don't want the current form)
  
  local current_movement = function()
    local movement = EoHS.unit_type_considering_variations(unit).movement
    for i,effect_pair in ipairs(extra_effects) do
      local effect = effect_pair[2]
      if effect.apply_to == "movement" then
        if effect.set then movement = effect.set end
        if effect.increase then movement = movement + effect.increase end
      end
    end
    return movement
  end
 
  -- TODO: make sure stacking all the transformations turns out OK
  
  if variables.spiritform then
    -- Overwrite most stuff, but not hitpoints
    extra_attacks = {}
    extra_effects = {}
    extra_effects_before_extra_attacks = {}
    default_melee_effects = {}
    make_effect("movement", { increase=2 })
    if unit.level < 2 then unit.type = "Ghost"
    else
      if variables.spiritform_kind == "wraith" then
        unit.type = (unit.level < 3) and "Wraith" or "Spectre"
      else
        unit.type = (unit.level < 3) and "Shadow" or "Nightgaunt"
      end
    end
    local spirit_cfg = EoHS.get_unit_type(unit.type)
    
    if not variables.is_wizard then hitpoints = math.max(1, math.floor((hitpoints*6+5)/10)) end
    
    -- TODO: aggregate the code for these and use that for all the type-changing effects
    unit.alignment = spirit_cfg.alignment
    EoHS.set_unit_race(unit, spirit_cfg.race)
    type_name_override = EoHS.substitute(_"$1| ($2|)", {spirit_cfg.name, type_name_override or original_type_cfg.name})
  end
  
  if variables.ogre_fury then
    extra_attacks = {}
    extra_effects = {}
    extra_effects_before_extra_attacks = {}
    default_melee_effects = {}
    unit.type = (unit.level>0) and "Ogre" or "Young Ogre"
    hitpoints = EoHS.get_unit_type(unit.type).hitpoints
    if unit.level > 1 then
      hitpoints = hitpoints + 26*(unit.level-1)
      make_effect("attack", { name = "cleaver", increase_damage = 4*(unit.level-1) })
    end
    if unit.level == 0 then
      -- Being able to make Ogres from 6g Ruffians would feel unreasonable.
      -- But making Young Ogres with normal stats would be very disappointing and a waste of mana/gold.
      -- So we compromise.
      hitpoints = hitpoints + 5
      make_effect("attack", { name = "cleaver", increase_damage = 3 })
    end
    local new_type_cfg = EoHS.unit_type_considering_variations(unit)
    unit.alignment = new_type_cfg.alignment
    EoHS.set_unit_race(unit, new_type_cfg.race)
    type_name_override = EoHS.substitute(_"$1| ($2|)", {new_type_cfg.name, type_name_override or original_type_cfg.name})
  end
  
  if variables.mud_touched then
    local movement = current_movement()
    local new_name_override
    if unit.level < 1 then
      unit.type = "Mudcrawler"
      extra_attacks = {}
      extra_effects = {}
      extra_effects_before_extra_attacks = {}
      default_melee_effects = {}
    else
      local best_melee  = 0
      local best_ranged = 0
      local consider_attack = function(attack)
        attack = EoHS.deep_copy(attack)
        for i,effect_pair in ipairs(extra_effects) do
          local effect = effect_pair[2]
          if (effect.apply_to == "attack") and EoHS.game_action_simulations.attack_matches_filter(attack, effect) then
            attack.damage = attack.damage + (effect.increase_damage or 0)
            attack.number = attack.number + (effect.increase_attacks or 0)
          end
        end
        local power = attack.damage*attack.number
        if attack.range == "melee"  then best_melee  = math.max(best_melee , power) end
        if attack.range == "ranged" then best_ranged = math.max(best_ranged, power) end
      end
      for i,attack in ipairs(EoHS.get_subtags(EoHS.unit_type_considering_variations(unit),"attack")) do consider_attack(attack) end
      for i,attack in ipairs(extra_attacks) do consider_attack(attack) end
      
      unit.type = "Giant Mudcrawler"
      if unit.level > 4 then
        new_name_override = _"Titanic Mudcrawler"
      else new_name_override = ({nil, _"Enormous Mudcrawler", _"Gargantuan Mudcrawler", _"Colossal Mudcrawler", _"Titanic Mudcrawler"})[unit.level] end
      extra_attacks = {}
      extra_effects = {}
      extra_effects_before_extra_attacks = {}
      default_melee_effects = {}
      
      local bonus = math.floor(math.abs(best_ranged - best_melee)/3)
      -- Try to keep things equal power, given that a bonus to your weaker attack is generally less good than a penalty to your primary attack.
      if best_ranged < best_melee then
           best_ranged = best_ranged + bonus
           best_melee  = best_melee  - (bonus/2)
      else best_melee  = best_melee  + bonus
           best_ranged = best_ranged - (bonus/2) end
      -- Favor ranged, because mudcrawlers do
      best_melee  = best_melee  - 2
      best_ranged = best_ranged + 2
      local swings_bonus = ((best_ranged + best_melee) > 45) and 1 or 0
      make_effect("attack", { range = "melee" , increase_damage = math.floor(0.5 + best_melee /(2+swings_bonus))-7, increase_attacks = swings_bonus })
      make_effect("attack", { range = "ranged", increase_damage = math.floor(0.5 + best_ranged/(3+swings_bonus))-5, increase_attacks = swings_bonus })
      if unit.level > 1 then
        local size = 72 + (unit.level-1)*14
        local crop =      (unit.level-1)*5
        make_effect("image_mod", { add = "~SCALE("..size..","..size..")~CROP(0,"..crop..","..size..","..(size-crop)..")" })
      end
    end
    make_effect("movement", { set = math.floor(movement / 2) })
    local new_type_cfg = EoHS.unit_type_considering_variations(unit)
    unit.alignment = new_type_cfg.alignment
    EoHS.set_unit_race(unit, new_type_cfg.race)
    type_name_override = EoHS.substitute(_"$1| ($2|)", {new_name_override or new_type_cfg.name, type_name_override or original_type_cfg.name})
  end
  
  local needs_undead_trait = false
  if variables.undying then
    make_effect("new_ability", { { "abilities", { {"dummy",{
      name=_"undying",
      description=_"This unit is unkillable; if it is reduced to 0 HP, it returns with 1 HP at the end of its next turn, or the next time the hex is empty.",
    }} }}})
    -- Adding the type name change isn't strictly necessary, since we add a dummy ability anyway,
    -- but it adds to the spell's coolness, which is important,
    type_name_override = EoHS.substitute(_"Undying $1|", {type_name_override or original_type_cfg.name})
  end
  if variables.is_reanimated and (unit.race ~= "undead") then
    if not variables.undying then
      type_name_override = EoHS.substitute(_"Undead $1|", {type_name_override or original_type_cfg.name})
    end
    needs_undead_trait = true
    EoHS.set_unit_race(unit, "undead")
    unit.alignment = "chaotic"
    local example = EoHS.unit_type_generic_example_considering_variations(unit)
    local new_resistances = EoHS.deep_copy(EoHS.get_subtag(example, "resistance"))
    local new_movement_costs = EoHS.deep_copy(EoHS.get_subtag(example, "movement_costs"))
    local new_defenses = EoHS.deep_copy(EoHS.get_subtag(example, "defense"))
    for i,effect_pair in ipairs(extra_effects) do
      local effect = effect_pair[2]
      if effect.apply_to == "resistance" then
        for k,v in pairs(EoHS.get_subtag(effect, "resistance")) do
          new_resistances[k] = (effect.replace and 0 or new_resistances[k] or 100) + v
        end
      end
      if effect.apply_to == "defense" then
        for k,v in pairs(EoHS.get_subtag(effect, "defense")) do
          if effect.replace or new_defenses[k] then
            new_defenses[k] = (effect.replace and 0 or new_defenses[k]) + v
          end
        end
      end
      if effect.apply_to == "movement_costs" then
        for k,v in pairs(EoHS.get_subtag(effect, "movement_costs")) do
          if effect.replace or new_movement_costs[k] then
            new_movement_costs[k] = (effect.replace and 0 or new_movement_costs[k]) + v
          end
        end
      end
    end
    local movement = current_movement()
    
    if new_defenses      .fungus      and (new_defenses      .fungus      > 30) then new_defenses      .fungus      = math.max(new_defenses.fungus      - 10, 30) end
    if new_defenses      .frozen      and (new_defenses      .frozen      > 60) then new_defenses      .frozen      = math.max(new_defenses.frozen      - 10, 60) end
    if new_movement_costs.frozen      and (new_movement_costs.frozen      >  2) then new_movement_costs.frozen      =    new_movement_costs.frozen      -  1      end
    if new_movement_costs.swamp_water and (new_movement_costs.swamp_water >  2) then new_movement_costs.swamp_water =    new_movement_costs.swamp_water -  1      end
    if new_movement_costs.shallow_water and (new_movement_costs.shallow_water <= movement) and not new_movement_costs.deep_water then
      new_movement_costs.deep_water =  new_movement_costs.shallow_water + 1
      new_defenses      .deep_water = (new_defenses      .shallow_water or 80) + 10
      make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_SUBMERGE } })
    end
    
    -- These comments were copied verbatim from the old EoHS 1.1 line, except for obvious mistakes.
    -- In general: Go for Lich-type resistances. (Lich, Ancient Lich, Death Knight, and Chocobone have those resistances at the time of this writing, with the only difference being Lich having -40% arcane instead of -50%.)
    -- A human/elf/orc/goblin should gain exact Lich resistances.
    -- Usually don't increase extreme resistances/weaknesses, because the fantasy mechanism for them is usually unrelated and non-interacting with the reason undead have these weaknesses.

    -- All existing physical undead, except the bizarre Skeletal Dragon, have either -40% or -50% arcane resistance.
    -- Decide which based on whether the unit is weak to arcane already.
    -- But don't reduce its resistance if it's already huge for some reason.
    new_resistances.arcane = math.max(new_resistances.arcane, (new_resistances.arcane > 100) and 150 or 140)

    -- All skeleton(ish) undead have -20% fire resistance. Dragons have 0%, ghouls have 10%.
    -- Leave the high fire weakness alone.
    -- Everything else does pretty much what I want if I just reduce it by 20% (cap at -20%.) Not-quite-as-fire-resistant drakes seem to make sense.
    new_resistances.fire = math.max(new_resistances.fire, math.min(120, new_resistances.fire + 20))

    -- Liches have -10% impact resist. Skeletons (including the dragon) -20%, ghouls 0%.
    -- Leave the high impact weakness alone.
    -- Units with huge impact resistance are usually that way because of attributes that SHOULDN'T change on an undead (exo-skeleton for Giant Scorpions, non-structuralness for mudcrawlers)
    -- Everything else does pretty much what I want if I just reduce it by 10% (cap at -10%.)
    new_resistances.impact = (new_resistances.impact>=50) and math.max(new_resistances.impact, math.min(110, new_resistances.impact + 10)) or new_resistances.impact

    -- Liches (and ghouls) have 10% blade resist. Skeletons (including the dragon) 40%.
    -- Leave the high blade resistance alone.
    -- Everything else does pretty much what I want if I just increase it by 10% (cap at 40%.)
    new_resistances.blade = math.min(new_resistances.blade, math.max(60, new_resistances.blade - 10))

    -- Liches (and ghouls) have 30% pierce resist. Skeletons (including the dragon) 60%.
    -- Leave the high pierce resistance alone.
    -- Everything else does pretty much what I want if I just increase it by 30% (cap at 60%.)
    new_resistances.pierce = math.min(new_resistances.pierce, math.max(40, new_resistances.pierce - 30))

    -- All skeleton(ish) undead have 60% cold resistance; ghouls have 40%.
    -- Leave the high cold resistance alone.
    -- Everything else does pretty much what I want if I just increase it by 60% (cap at 60%.)
    -- 2.0 note: Changed cap to 70%, like the ghost.
    new_resistances.cold = math.min(new_resistances.cold, math.max(30, new_resistances.cold - 60))
    
    make_effect("resistance"    , { replace=true, {"resistance"    ,new_resistances   }})
    make_effect("defense"       , { replace=true, {"defense"       ,new_defenses      }})
    make_effect("movement_costs", { replace=true, {"movement_costs",new_movement_costs}})
    make_effect("image_mod"     , { add = "~CS(110,110,110)~CS(-130,-120,-110)" })
  end
  if variables.undying then
    make_effect("image_mod"     , { add = "~CS(90,70,70)" })
  end
    
  -- TODO: Can we distribute some of these into their own files?
  if variables.touch_enchantment == "mud_touch" then
    table.insert(default_melee_effects, { { "set_specials", { mode = "append", EoHS.mud_touch_special }}})
  end
  if variables.touch_enchantment == "dispelling_touch" then
    table.insert(default_melee_effects, { { "set_specials", { mode = "append", EoHS.dispelling_touch_special }}})
  end
  if variables.touch_enchantment == "reanimating_touch" then
    table.insert(default_melee_effects, { { "set_specials", { mode = "append", EoHS.reanimating_touch_special }}})
  end
    
  for i,effect in ipairs(default_melee_effects) do
    effect.range = "melee"
    make_effect("attack", effect)
  end
  
  local final_type_cfg = EoHS.unit_type_considering_variations (unit)
  
  local type_hitpoints = final_type_cfg.hitpoints
  if hitpoints ~= type_hitpoints then
    make_effect("hitpoints", { increase_total = hitpoints-type_hitpoints })
  end
  local type_experience = final_type_cfg.experience
  if experience ~= type_experience then
    make_effect("max_experience", { increase = experience-type_experience })
  end
  if force_zoc ~= nil then
    make_effect("zoc", { value=force_zoc })
  end
  
  variables.type_name_override = type_name_override
  
  for i,attack in ipairs(extra_attacks) do attack.apply_to = "new_attack"; table.insert(extra_effects_before_extra_attacks, {"effect",attack}) end
  for i,effect in ipairs(extra_effects) do table.insert(extra_effects_before_extra_attacks, effect) end
  extra_effects,extra_attacks,extra_effects_before_extra_attacks = extra_effects_before_extra_attacks,nil,nil
  extra_effects.id = "EoHS_type_adjustment_advancement"
  
  local modifications = EoHS.force_subtag(unit, "modifications")
  EoHS.remove_subtags(modifications, "advancement", "EoHS_type_adjustment_advancement")
  if extra_effects[1] then
    table.insert(modifications, 1, { "advancement", extra_effects }) -- advancement comes before trait or object - it's fitting for type modifications
  end
  
  EoHS.remove_subtags(modifications, "object", "EoHS_mount_object")
  if variables.is_mounted then
    -- an object at the beginning: unaffected by traits (good), always affected by scenario equipment (not good, but better than depending on order added)
    table.insert(modifications, 1, { "object", EoHS.get_mount_effects(unit) })
  end
  
  -- times="per level" effects don't respect our level= overrides. Circumvent this.
  for i,modification_tag in ipairs(modifications) do
    EoHS.remove_subtags(modification_tag[2], "effect", function(t) return t.EoHS_per_level_replacement end)
    for effect in wml.child_range(modification_tag[2], "effect") do
      if effect.times == "per level" then
        effect.EoHS_per_level_apply_to = effect.apply_to or effect.EoHS_per_level_apply_to
        effect.apply_to = nil
        local single_effect = EoHS.deep_copy(effect)
        single_effect.EoHS_per_level_apply_to = nil
        single_effect.apply_to = effect.EoHS_per_level_apply_to
        single_effect.EoHS_per_level_replacement = true
        single_effect.times = nil
        for l=1,unit.level do
          table.insert(modification_tag[2], {"effect",single_effect})
        end
      end
    end
  end
  
  EoHS.prepare_max_moves_change(unit)
  EoHS.prepare_max_hitpoints_change(unit)
  
  -- TODO can we overwrite less stuff, to increase compatibility?
  local rewritten_subtags = {attack=true,abilities=true,defense=true,resistance=true,movement_costs=true}
  EoHS.remove_subtags(unit,"*",function(val,tagname) return rewritten_subtags[tagname] end)
  unit.max_hitpoints = nil
  unit.max_experience = nil
  unit.max_moves = nil
  unit.zoc = nil
  EoHS.get_fake_subtag(variables, "unit_attribute_memory").type = unit.type
  
  -- Wesnoth will automatically re-add these if appropriate
  EoHS.set_subtag_attribute(unit, "status.unpoisonable")
  EoHS.set_subtag_attribute(unit, "status.undrainable")
  EoHS.set_subtag_attribute(unit, "status.unplagueable")
  EoHS.remove_subtags(modifications, "trait", "undead")
  EoHS.remove_subtags(modifications, "trait", "elemental")
  EoHS.remove_subtags(modifications, "trait", "mechanical")
  -- Except for reanimated units, becuase they're not a unit type that specifies it
  if needs_undead_trait then
    table.insert(modifications, EoHS.macros.TRAIT_UNDEAD[1])
  end
  
  EoHS.check_wml_table(unit)
  EoHS.shallow_overwrite(unit, EoHS.create_wunit(unit).__cfg)
  EoHS.finish_max_moves_change(unit)
  EoHS.finish_max_hitpoints_change(unit)
  
  if EoHS.get_subtag_attribute(unit, "status.unpoisonable") then
    EoHS.set_subtag_attribute(unit, "status.poisoned")
  end
  
  -- Has to be done after the main regeneration above
  EoHS.update_conditional_abilities(unit)
  -- Hack, in case the unit's level was changed
  if variables.wizard_sword_turns then EoHS.update_wizard_sword(unit) end
  
  EoHS.standardize_unit(unit)
  --EoHS.update_unit_graphics(unit) (standardize_unit calls it)
end

EoHS.abilities = {}
EoHS.abilities.regen_lesser = { {"regenerate",{
  value = 4,
  id = "EoHS_regen_lesser",
  name = _"regen +4",
  description = _"The unit will heal itself 4 HP per turn. If it is poisoned, it will remove the poison instead of healing.",
  affect_self = true,
  poison = "cured",
}} }
EoHS.abilities.invisible = { {"hides",{
  id = "EoHS_invisible",
  name= _ "invisible",
  female_name= _ "female^invisible",
  name_inactive= _ "invisible",
  female_name_inactive= _ "female^invisible",
  description = _"This unit can hide anywhere, and remain undetected by its enemies.\n\nEnemy units cannot see this unit, except if they have units next to it. Any enemy unit that first discovers this unit immediately loses all its remaining movement.",
  affect_self = true,
}} }
EoHS.abilities.underfoot = {
      { "teleport", {
        id = "EoHS_underfoot",
        name= _ "underfoot",
        female_name= _ "female^underfoot",
        description= _ "This unit may teleport to anywhere next to a friendly unit (except other units with this ability).",
        { "tunnel", {
          id = "EoHS_underfoot",
          { "filter", {
            ability = "EoHS_underfoot",
          } },
          { "source", {
          } },
          { "target", {
            { "not", {
              { "filter", {
              } },
            } },
            { "filter_adjacent_location", {
              { "filter", {
                { "filter_side", {
                  { "allied_with", {
                    side="$teleport_unit.side"
                  } },
                } },
                { "not", {
                  ability = "EoHS_underfoot",
                } },
              } },
            } },
          } },
        } },
      } },
    }
EoHS.abilities.deluminates = EoHS.deep_copy(EoHS.macros.ABILITY_ILLUMINATES)
EoHS.abilities.deluminates[1][2].value = -25
EoHS.abilities.deluminates[1][2].min_value = -25
EoHS.abilities.deluminates[1][2].max_value = nil
EoHS.abilities.deluminates[1][2].name= _ "deluminates"
EoHS.abilities.deluminates[1][2].female_name= _ "female^deluminates"
EoHS.abilities.deluminates[1][2].description= _ "This unit deluminates the surrounding area, making chaotic units fight better, and lawful units fight worse.\n\nAny units adjacent to this unit will fight as if it were night when it is dusk, and as if it were dusk when it is day."
EoHS.abilities.twilight = {EoHS.deep_copy(EoHS.macros.ABILITY_ILLUMINATES[1]),EoHS.deep_copy(EoHS.abilities.deluminates[1])}
EoHS.abilities.twilight[1][2].max_value = 0
table.insert(EoHS.abilities.twilight[1][2], { "filter_base_value", { less_than = 0 }})
EoHS.abilities.twilight[2][2].min_value = 0
table.insert(EoHS.abilities.twilight[2][2], { "filter_base_value", { greater_than = 0 }})
EoHS.abilities.twilight[1][2].name= _ "twilight"
EoHS.abilities.twilight[1][2].female_name= _ "female^twilight"
EoHS.abilities.twilight[1][2].description= _ "Any units adjacent to this unit will fight as if it were twilight at all times."
EoHS.abilities.twilight[2][2].name= nil
EoHS.abilities.twilight[2][2].female_name= nil
EoHS.abilities.twilight[2][2].description= nil
EoHS.abilities.protection = {
  { "resistance", {
    id = "EoHS_protection",
    cumulative = false,
    add = 30,
    max_value = 70,
    { "filter_base_value", { less_than = 70, }},
    affect_self = false,
    { "affect_adjacent", {
      adjacent = "n,ne,se,s,sw,nw",
    }},
           name = _"protection",
    female_name = _"female^protection",
    description = _"Your adjacent units get a 30% bonus to all resistances, to a maximum of 70%.",
  }}
}
EoHS.abilities.despair = {
  { "dummy", {
    id = "EoHS_despair",
           name = _"despair",
    female_name = _"female^despair",
    description = _"All enemy units within two hexes do 30% less damage.",
  }}
}
EoHS.despair_receiver_ability = { "leadership", {
  id = "EoHS_despair_receiver",
  cumulative = true,
  value = -30,
  affect_self = true,
  { "filter", {
    lua_function = "EoHS_despair_receiver_check"
    --[[ Much too slow:
    { "filter_location", {
      radius = 2,
      { "filter", { ability = "EoHS_despair", { "filter_side", { {"enemy_of",{side="$this_unit.side"}} }} }},
      { "filter_radius", { {"not",{ terrain="_*,X*" }}, {"not",{ terrain="*^_*,*^X*" }} }}, -- TODO name this filter
    }},]]
  }},
}}
EoHS.make_filter_func("EoHS_despair_receiver_check", function(wunit)
  if EoHS.simplify_simulated_combats then return false end
  for something = wunit.x - 2,wunit.x + 2 do for whatever = wunit.y - 2,wunit.y + 2 do
    local wunit2 = wesnoth.units.get (something, whatever)
    if wunit2 and (not wunit2.status.petrified) and wesnoth.sides.is_enemy(wunit.side, wunit2.side) and wunit2.variables.EoHS_despair_ability and EoHS.distance_between (wunit.x, wunit.y, something, whatever, EoHS.passable_only(), 2) <= 2 then return true end
  end end
  return false
end)
EoHS.abilities.light_control = {
  { "dummy", {
    id = "EoHS_light_control",
           name = _"light control",
    female_name = _"female^light control",
    description = _"All units within two hexes fight as if it was one time-of-day step in your favor (better for allies, worse for enemies). Technically uses 'leadership' abilities because the Wesnoth engine doesn't support an ability illuminating just one hex at a time",
  }}
}
EoHS.light_control_receiver_leadership_abilities_hack = {
  {"leadership",{
    id="EoHS_light_control_receiver",
    value=25,
    cumulative=true,
    affect_self=true,
    { "filter", {
      lua_function = "EoHS_light_control_receiver_ally_check"
    }},
  }},
  {"leadership",{
    id="EoHS_light_control_receiver",
    value=-25,
    cumulative=true,
    affect_self=true,
    { "filter", {
      lua_function = "EoHS_light_control_receiver_enemy_check"
    }},
  }},
}
EoHS.light_control_receiver_abilities = {
  neutral = {
    { "dummy", {
      id = "EoHS_light_control_receiver",
    }}
  },
  lawful = EoHS.light_control_receiver_leadership_abilities_hack,--[[{
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=25,
      max_value=25,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter", {
        lua_function = "EoHS_light_control_receiver_ally_check"
      }},
    }},
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=-25,
      max_value=-25,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter", {
        lua_function = "EoHS_light_control_receiver_enemy_check"
      }},
    }},
  },]]
  chaotic = EoHS.light_control_receiver_leadership_abilities_hack,--[[{
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=25,
      max_value=25,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter", {
        lua_function = "EoHS_light_control_receiver_enemy_check"
      }},
    }},
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=-25,
      max_value=-25,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter", {
        lua_function = "EoHS_light_control_receiver_ally_check"
      }},
    }},
  },]]
  liminal = EoHS.light_control_receiver_leadership_abilities_hack,--[[{
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=25,
      max_value=25,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter_base_value", { greater_than_equal_to = 0 }},
      { "filter", {
        lua_function = "EoHS_light_control_receiver_enemy_check"
      }},
    }},
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=-25,
      max_value=-25,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter_base_value", { less_than = 0 }},
      { "filter", {
        lua_function = "EoHS_light_control_receiver_enemy_check"
      }},
    }},
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=25,
      max_value=0,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter_base_value", { less_than = 0 }},
      { "filter", {
        lua_function = "EoHS_light_control_receiver_ally_check"
      }},
    }},
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=-25,
      max_value=0,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter_base_value", { greater_than = 0 }},
      { "filter", {
        lua_function = "EoHS_light_control_receiver_ally_check"
      }},
    }},
  },]]
}
EoHS.make_filter_func("EoHS_light_control_receiver_enemy_check", function(wunit)
  if EoHS.simplify_simulated_combats then return false end
  local tod = wesnoth.schedule.get_illumination({ wunit.x, wunit.y })
  local alignment = wunit.variables.EoHS_unit_attribute_memory_alignment
  if (alignment == "lawful" ) and ((tod.lawful_bonus < 0) or (wunit.variables.EoHS_unit_attribute_memory_is_fearless and (tod.lawful_bonus == 0))) then return false end
  if (alignment == "chaotic") and ((tod.lawful_bonus > 0) or (wunit.variables.EoHS_unit_attribute_memory_is_fearless and (tod.lawful_bonus == 0))) then return false end
  if (alignment == "liminal") and (tod.lawful_bonus ~= 0) then return false end
  for something = wunit.x - 2,wunit.x + 2 do for whatever = wunit.y - 2,wunit.y + 2 do
    local wunit2 = wesnoth.units.get (something, whatever)
    if wunit2 and (not wunit2.status.petrified) and wesnoth.sides.is_enemy(wunit.side, wunit2.side) and wunit2.variables.EoHS_light_control_ability and EoHS.distance_between (wunit.x, wunit.y, something, whatever, EoHS.passable_only(), 2) <= 2 then return true end
  end end
  return false
end)
EoHS.make_filter_func("EoHS_light_control_receiver_ally_check", function(wunit)
  if EoHS.simplify_simulated_combats then return false end
  local tod = wesnoth.schedule.get_illumination({ wunit.x, wunit.y })
  local alignment = wunit.variables.EoHS_unit_attribute_memory_alignment
  if (alignment == "lawful" ) and ((tod.lawful_bonus > 0) or (wunit.variables.EoHS_unit_attribute_memory_is_fearless and (tod.lawful_bonus < 0))) then return false end
  if (alignment == "chaotic") and ((tod.lawful_bonus < 0) or (wunit.variables.EoHS_unit_attribute_memory_is_fearless and (tod.lawful_bonus > 0))) then return false end
  if (alignment == "liminal") and (tod.lawful_bonus == 0) then return false end
  for something = wunit.x - 2,wunit.x + 2 do for whatever = wunit.y - 2,wunit.y + 2 do
    local wunit2 = wesnoth.units.get (something, whatever)
    if wunit2 and (not wunit2.status.petrified) and (not wesnoth.sides.is_enemy(wunit.side, wunit2.side)) and wunit2.variables.EoHS_light_control_ability and EoHS.distance_between (wunit.x, wunit.y, something, whatever, EoHS.passable_only(), 2) <= 2 then return true end
  end end
  return false
end)
EoHS.abilities.intimidate = { { "leadership", {
      id = "EoHS_intimidate",
      cumulative = false,
      value = "(15*(other.level-level))",
      affect_self = false,
      affect_allies = false,
      affect_enemies = true,
      { "affect_adjacent", {
        { "filter", {
          formula = "level < other.level"
        }},
      }},
             name = _"intimidate",
      female_name = _"female^intimidate",
      description = _"Adjacent enemy units of lower level will do 15% less damage times the level difference.",
    }} }

-- TODO: Maybe this should be in a different file? It's not really about unit types.
local conditional_ability_data = {}
EoHS.make_conditional_ability = function(id, func)
  table.insert(conditional_ability_data, {id="EoHS_"..id,func=func})
  conditional_ability_data["EoHS_"..id] = true
end
EoHS.update_conditional_abilities = function(unit)
  local modifications = EoHS.force_subtag(unit, "modifications")
  local abilities_tag = EoHS.force_subtag(unit, "abilities")
  if abilities_tag then EoHS.remove_subtags(abilities_tag, "*", function(a) return conditional_ability_data[a.id] end) end
  EoHS.remove_subtags(modifications, "object", "EoHS_conditional_abilities_object")
  local abilities = {}
  for i,data in ipairs(conditional_ability_data) do
    local ability = data.func(unit)
    if ability then
      ability[2].id = data.id
      table.insert(abilities, ability)
      if not abilities_tag then abilities_tag = EoHS.force_subtag(unit, "abilities") end
      table.insert(abilities_tag, ability)
    end
  end
  if abilities[1] then
    table.insert(modifications, {"object",{ id="EoHS_conditional_abilities_object", {"effect",{ apply_to = "new_ability", {"abilities",abilities}}}}})
  end
  
  -- We could do this. But to be polite to add-ons that add abilities crudely, we just mess with the existing abilities tag (see above).
  -- EoHS.remove_subtags(unit, "abilities")
end

-->>)}
